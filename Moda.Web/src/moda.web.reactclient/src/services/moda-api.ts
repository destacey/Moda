//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getStartup( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/startup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStartup(_response);
        });
    }

    protected processGetStartup(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PermissionsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all permissions.
     */
    getList( cancelToken?: CancelToken): Promise<ApplicationPermission[]> {
        let url_ = this.baseUrl + "/api/user-management/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ApplicationPermission[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ApplicationPermission[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationPermission[]>(null as any);
    }
}

export class ProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get profile details of currently logged in user.
     */
    get( cancelToken?: CancelToken): Promise<UserDetailsDto> {
        let url_ = this.baseUrl + "/api/user-management/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UserDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDetailsDto>(null as any);
    }

    /**
     * Update profile details of currently logged in user.
     */
    update(request: UpdateProfileRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/user-management/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get permissions of currently logged in user.
     */
    getPermissions( cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/user-management/profiles/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get internal employee id of currently logged in user.
     */
    getInternalEmployeeId( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/user-management/profiles/internal-employee-id";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInternalEmployeeId(_response);
        });
    }

    protected processGetInternalEmployeeId(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get audit logs of currently logged in user.
     */
    getLogs( cancelToken?: CancelToken): Promise<AuditDto[]> {
        let url_ = this.baseUrl + "/api/user-management/profiles/logs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLogs(_response);
        });
    }

    protected processGetLogs(response: AxiosResponse): Promise<AuditDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AuditDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditDto[]>(null as any);
    }
}

export class RolesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all roles.
     */
    getList( cancelToken?: CancelToken): Promise<RoleListDto[]> {
        let url_ = this.baseUrl + "/api/user-management/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RoleListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoleListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleListDto[]>(null as any);
    }

    /**
     * Create or update a role.
     */
    createOrUpdate(request: CreateOrUpdateRoleRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/user-management/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrUpdate(_response);
        });
    }

    protected processCreateOrUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get role details.
     */
    getById(id: string, cancelToken?: CancelToken): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoleDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * Delete a role.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get role details with its permissions.
     */
    getByIdWithPermissions(id: string, cancelToken?: CancelToken): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/user-management/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByIdWithPermissions(_response);
        });
    }

    protected processGetByIdWithPermissions(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoleDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * Update a role's permissions.
     */
    updatePermissions(id: string, request: UpdateRolePermissionsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/user-management/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePermissions(_response);
        });
    }

    protected processUpdatePermissions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UsersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get list of all users.
     */
    getList( cancelToken?: CancelToken): Promise<UserDetailsDto[]> {
        let url_ = this.baseUrl + "/api/user-management/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<UserDetailsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UserDetailsDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDetailsDto[]>(null as any);
    }

    /**
     * Get a user's details.
     */
    getById(id: string, cancelToken?: CancelToken): Promise<UserDetailsDto> {
        let url_ = this.baseUrl + "/api/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<UserDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UserDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDetailsDto>(null as any);
    }

    /**
     * Get a user's roles.
     * @param includeUnassigned (optional) 
     */
    getRoles(id: string, includeUnassigned: boolean | undefined, cancelToken?: CancelToken): Promise<UserRoleDto[]> {
        let url_ = this.baseUrl + "/api/user-management/users/{id}/roles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeUnassigned === null)
            throw new Error("The parameter 'includeUnassigned' cannot be null.");
        else if (includeUnassigned !== undefined)
            url_ += "includeUnassigned=" + encodeURIComponent("" + includeUnassigned) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<UserRoleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UserRoleDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserRoleDto[]>(null as any);
    }

    /**
     * Update a user's assigned roles.
     */
    manageRoles(id: string, request: AssignUserRolesRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/user-management/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManageRoles(_response);
        });
    }

    protected processManageRoles(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Toggle a user's active status.
     */
    toggleStatus(id: string, request: ToggleUserStatusRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/user-management/users/{id}/toggle-status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleStatus(_response);
        });
    }

    protected processToggleStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StrategicThemesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of strategic themes.
     * @param state (optional) 
     */
    getStrategicThemes(state: number | null | undefined, cancelToken?: CancelToken): Promise<StrategicThemeListDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes?";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStrategicThemes(_response);
        });
    }

    protected processGetStrategicThemes(response: AxiosResponse): Promise<StrategicThemeListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategicThemeListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategicThemeListDto[]>(null as any);
    }

    /**
     * Create a strategic theme.
     */
    create(request: CreateStrategicThemeRequest, cancelToken?: CancelToken): Promise<ObjectIdAndKey> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObjectIdAndKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<ObjectIdAndKey>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectIdAndKey>(null as any);
    }

    /**
     * Get strategic themes details.
     */
    getStrategicTheme(idOrKey: string, cancelToken?: CancelToken): Promise<StrategicThemeDetailsDto> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStrategicTheme(_response);
        });
    }

    protected processGetStrategicTheme(response: AxiosResponse): Promise<StrategicThemeDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategicThemeDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategicThemeDetailsDto>(null as any);
    }

    /**
     * Update a strategic theme.
     */
    update(id: string, request: UpdateStrategicThemeRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a strategic theme.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all strategic theme states.
     */
    getStateOptions( cancelToken?: CancelToken): Promise<StrategicThemeStateDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/strategic-themes/states";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStateOptions(_response);
        });
    }

    protected processGetStateOptions(response: AxiosResponse): Promise<StrategicThemeStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategicThemeStateDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategicThemeStateDto[]>(null as any);
    }
}

export class StrategiesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of strategies.
     * @param status (optional) 
     */
    getStrategies(status: number | null | undefined, cancelToken?: CancelToken): Promise<StrategyListDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies?";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStrategies(_response);
        });
    }

    protected processGetStrategies(response: AxiosResponse): Promise<StrategyListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategyListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategyListDto[]>(null as any);
    }

    /**
     * Create a strategy.
     */
    create(request: CreateStrategyRequest, cancelToken?: CancelToken): Promise<ObjectIdAndKey> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObjectIdAndKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<ObjectIdAndKey>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectIdAndKey>(null as any);
    }

    /**
     * Get strategy details.
     */
    getStrategy(idOrKey: string, cancelToken?: CancelToken): Promise<StrategyDetailsDto> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStrategy(_response);
        });
    }

    protected processGetStrategy(response: AxiosResponse): Promise<StrategyDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategyDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategyDetailsDto>(null as any);
    }

    /**
     * Update a strategy.
     */
    update(id: string, request: UpdateStrategyRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a strategy.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all strategy statuses.
     */
    getStatusOptions( cancelToken?: CancelToken): Promise<StrategyStatusDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/strategies/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatusOptions(_response);
        });
    }

    protected processGetStatusOptions(response: AxiosResponse): Promise<StrategyStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StrategyStatusDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StrategyStatusDto[]>(null as any);
    }
}

export class VisionsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of visions.
     * @param state (optional) 
     */
    getVisions(state: number | null | undefined, cancelToken?: CancelToken): Promise<VisionDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/visions?";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVisions(_response);
        });
    }

    protected processGetVisions(response: AxiosResponse): Promise<VisionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<VisionDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisionDto[]>(null as any);
    }

    /**
     * Create a vision.
     */
    create(request: CreateVisionRequest, cancelToken?: CancelToken): Promise<ObjectIdAndKey> {
        let url_ = this.baseUrl + "/api/strategic-management/visions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObjectIdAndKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<ObjectIdAndKey>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectIdAndKey>(null as any);
    }

    /**
     * Get vision details.
     */
    getVision(idOrKey: string, cancelToken?: CancelToken): Promise<VisionDto> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVision(_response);
        });
    }

    protected processGetVision(response: AxiosResponse): Promise<VisionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<VisionDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisionDto>(null as any);
    }

    /**
     * Update a vision.
     */
    update(id: string, request: UpdateVisionRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a vision.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Activate a vision.
     */
    activate(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Archive a vision.
     */
    archive(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArchive(_response);
        });
    }

    protected processArchive(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all vision states.
     */
    getStateOptions( cancelToken?: CancelToken): Promise<VisionStateDto[]> {
        let url_ = this.baseUrl + "/api/strategic-management/visions/states";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStateOptions(_response);
        });
    }

    protected processGetStateOptions(response: AxiosResponse): Promise<VisionStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<VisionStateDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisionStateDto[]>(null as any);
    }
}

export class PlanningIntervalsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of planning intervals.
     */
    getList( cancelToken?: CancelToken): Promise<PlanningIntervalListDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<PlanningIntervalListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalListDto[]>(null as any);
    }

    /**
     * Create a planning interval.
     */
    create(request: CreatePlanningIntervalRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get planning interval details.
     */
    getPlanningInterval(idOrKey: string, cancelToken?: CancelToken): Promise<PlanningIntervalDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPlanningInterval(_response);
        });
    }

    protected processGetPlanningInterval(response: AxiosResponse): Promise<PlanningIntervalDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalDetailsDto>(null as any);
    }

    /**
     * Get the PI calendar.
     */
    getCalendar(idOrKey: string, cancelToken?: CancelToken): Promise<PlanningIntervalCalendarDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{idOrKey}/calendar";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCalendar(_response);
        });
    }

    protected processGetCalendar(response: AxiosResponse): Promise<PlanningIntervalCalendarDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalCalendarDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalCalendarDto>(null as any);
    }

    /**
     * Get the PI predictability for all teams.
     */
    getPredictability(id: string, cancelToken?: CancelToken): Promise<PlanningIntervalPredictabilityDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/predictability";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPredictability(_response);
        });
    }

    protected processGetPredictability(response: AxiosResponse): Promise<PlanningIntervalPredictabilityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalPredictabilityDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalPredictabilityDto>(null as any);
    }

    /**
     * Update a planning interval.
     */
    update(id: string, request: UpdatePlanningIntervalRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of planning interval teams.
     */
    getTeams(id: string, cancelToken?: CancelToken): Promise<PlanningIntervalTeamResponse[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/teams";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeams(_response);
        });
    }

    protected processGetTeams(response: AxiosResponse): Promise<PlanningIntervalTeamResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalTeamResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalTeamResponse[]>(null as any);
    }

    /**
     * Manage planning interval teams.
     */
    manageTeams(id: string, request: ManagePlanningIntervalTeamsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/teams";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManageTeams(_response);
        });
    }

    protected processManageTeams(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get the PI predictability for a team.
     */
    getTeamPredictability(id: string, teamId: string, cancelToken?: CancelToken): Promise<number | null> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/teams/{teamId}/predictability";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamPredictability(_response);
        });
    }

    protected processGetTeamPredictability(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    /**
     * Manage planning interval dates and iterations.
     */
    manageDates(id: string, request: ManagePlanningIntervalDatesRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManageDates(_response);
        });
    }

    protected processManageDates(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of planning interval iterations.
     */
    getIterations(idOrKey: string, cancelToken?: CancelToken): Promise<PlanningIntervalIterationListDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{idOrKey}/iterations";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIterations(_response);
        });
    }

    protected processGetIterations(response: AxiosResponse): Promise<PlanningIntervalIterationListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalIterationListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalIterationListDto[]>(null as any);
    }

    /**
     * Get a list of iteration types.
     */
    getIterationTypes( cancelToken?: CancelToken): Promise<PlanningIntervalIterationTypeDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/iteration-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIterationTypes(_response);
        });
    }

    protected processGetIterationTypes(response: AxiosResponse): Promise<PlanningIntervalIterationTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalIterationTypeDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalIterationTypeDto[]>(null as any);
    }

    /**
     * Get a list of planning interval teams.
     * @param teamId (optional) 
     */
    getObjectives(id: string, teamId: string | null | undefined, cancelToken?: CancelToken): Promise<PlanningIntervalObjectiveListDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectives(_response);
        });
    }

    protected processGetObjectives(response: AxiosResponse): Promise<PlanningIntervalObjectiveListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalObjectiveListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalObjectiveListDto[]>(null as any);
    }

    /**
     * Create a planning interval objective.
     */
    createObjective(id: string, request: CreatePlanningIntervalObjectiveRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateObjective(_response);
        });
    }

    protected processCreateObjective(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get a planning interval objective.
     */
    getObjectiveById(id: string, objectiveId: string, cancelToken?: CancelToken): Promise<PlanningIntervalObjectiveDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectiveById(_response);
        });
    }

    protected processGetObjectiveById(response: AxiosResponse): Promise<PlanningIntervalObjectiveDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalObjectiveDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalObjectiveDetailsDto>(null as any);
    }

    /**
     * Update a planning interval objective.
     */
    updateObjective(id: string, objectiveId: string, request: UpdatePlanningIntervalObjectiveRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateObjective(_response);
        });
    }

    protected processUpdateObjective(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a planning interval objective.
     */
    deleteObjective(id: string, objectiveId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteObjective(_response);
        });
    }

    protected processDeleteObjective(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a planning interval objective using the PI and Objective keys.
     */
    getObjectiveByKey(id: number, objectiveId: number, cancelToken?: CancelToken): Promise<PlanningIntervalObjectiveDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/key/{id}/objectives/{objectiveId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectiveByKey(_response);
        });
    }

    protected processGetObjectiveByKey(response: AxiosResponse): Promise<PlanningIntervalObjectiveDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalObjectiveDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalObjectiveDetailsDto>(null as any);
    }

    /**
     * Update the order of planning interval objectives.
     */
    updateObjectivesOrder(id: string, request: UpdatePlanningIntervalObjectivesOrderRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/order";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateObjectivesOrder(_response);
        });
    }

    protected processUpdateObjectivesOrder(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a health report for planning interval objectives.
     * @param teamId (optional) 
     */
    getObjectivesHealthReport(idOrKey: string, teamId: string | null | undefined, cancelToken?: CancelToken): Promise<PlanningIntervalObjectiveHealthCheckDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{idOrKey}/objectives/health-report?";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectivesHealthReport(_response);
        });
    }

    protected processGetObjectivesHealthReport(response: AxiosResponse): Promise<PlanningIntervalObjectiveHealthCheckDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalObjectiveHealthCheckDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalObjectiveHealthCheckDto[]>(null as any);
    }

    /**
     * Get work items for an objective.
     */
    getObjectiveWorkItems(id: string, objectiveId: string, cancelToken?: CancelToken): Promise<WorkItemsSummaryDto> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}/work-items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectiveWorkItems(_response);
        });
    }

    protected processGetObjectiveWorkItems(response: AxiosResponse): Promise<WorkItemsSummaryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemsSummaryDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemsSummaryDto>(null as any);
    }

    /**
     * Manage objective work items.
     */
    manageObjectiveWorkItems(id: string, objectiveId: string, request: ManagePlanningIntervalObjectiveWorkItemsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}/work-items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManageObjectiveWorkItems(_response);
        });
    }

    protected processManageObjectiveWorkItems(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get metrics for the work items linked to an objective.
     */
    getObjectiveWorkItemMetrics(id: string, objectiveId: string, cancelToken?: CancelToken): Promise<WorkItemProgressDailyRollupDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/{objectiveId}/work-items/metrics";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (objectiveId === undefined || objectiveId === null)
            throw new Error("The parameter 'objectiveId' must be defined.");
        url_ = url_.replace("{objectiveId}", encodeURIComponent("" + objectiveId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectiveWorkItemMetrics(_response);
        });
    }

    protected processGetObjectiveWorkItemMetrics(response: AxiosResponse): Promise<WorkItemProgressDailyRollupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemProgressDailyRollupDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemProgressDailyRollupDto[]>(null as any);
    }

    /**
     * Import objectives for a planning interval from a csv file.
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     */
    importObjectives(id: string, contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/objectives/import";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportObjectives(_response);
        });
    }

    protected processImportObjectives(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all PI objective statuses.
     */
    getObjectiveStatuses( cancelToken?: CancelToken): Promise<PlanningIntervalObjectiveStatusDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/objective-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectiveStatuses(_response);
        });
    }

    protected processGetObjectiveStatuses(response: AxiosResponse): Promise<PlanningIntervalObjectiveStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PlanningIntervalObjectiveStatusDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanningIntervalObjectiveStatusDto[]>(null as any);
    }

    /**
     * Get planning interval risks.
     * @param teamId (optional) 
     * @param includeClosed (optional) 
     */
    getRisks(id: string, teamId: string | null | undefined, includeClosed: boolean | undefined, cancelToken?: CancelToken): Promise<RiskListDto[]> {
        let url_ = this.baseUrl + "/api/planning/planning-intervals/{id}/risks?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        if (includeClosed === null)
            throw new Error("The parameter 'includeClosed' cannot be null.");
        else if (includeClosed !== undefined)
            url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRisks(_response);
        });
    }

    protected processGetRisks(response: AxiosResponse): Promise<RiskListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskListDto[]>(null as any);
    }
}

export class RisksClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of risks.
     * @param includeClosed (optional) 
     */
    getList(includeClosed: boolean | undefined, cancelToken?: CancelToken): Promise<RiskListDto[]> {
        let url_ = this.baseUrl + "/api/planning/risks?";
        if (includeClosed === null)
            throw new Error("The parameter 'includeClosed' cannot be null.");
        else if (includeClosed !== undefined)
            url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RiskListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskListDto[]>(null as any);
    }

    /**
     * Create a risk.
     */
    createRisk(request: CreateRiskRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/planning/risks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRisk(_response);
        });
    }

    protected processCreateRisk(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get risk details by Id.
     */
    getRisk(idOrKey: string, cancelToken?: CancelToken): Promise<RiskDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/risks/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRisk(_response);
        });
    }

    protected processGetRisk(response: AxiosResponse): Promise<RiskDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskDetailsDto>(null as any);
    }

    /**
     * Get a list of open risks assigned to me.
     */
    getMyRisks( cancelToken?: CancelToken): Promise<RiskListDto[]> {
        let url_ = this.baseUrl + "/api/planning/risks/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyRisks(_response);
        });
    }

    protected processGetMyRisks(response: AxiosResponse): Promise<RiskListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskListDto[]>(null as any);
    }

    /**
     * Update a risk.
     */
    update(id: string, request: UpdateRiskRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/risks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Import risks from a csv file.
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     */
    import(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/risks/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all risk statuses.
     */
    getStatuses( cancelToken?: CancelToken): Promise<RiskStatusDto[]> {
        let url_ = this.baseUrl + "/api/planning/risks/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatuses(_response);
        });
    }

    protected processGetStatuses(response: AxiosResponse): Promise<RiskStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskStatusDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskStatusDto[]>(null as any);
    }

    /**
     * Get a list of all risk categories.
     */
    getCategories( cancelToken?: CancelToken): Promise<RiskCategoryDto[]> {
        let url_ = this.baseUrl + "/api/planning/risks/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<RiskCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskCategoryDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskCategoryDto[]>(null as any);
    }

    /**
     * Get a list of all risk grades.
     */
    getGrades( cancelToken?: CancelToken): Promise<RiskGradeDto[]> {
        let url_ = this.baseUrl + "/api/planning/risks/grades";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGrades(_response);
        });
    }

    protected processGetGrades(response: AxiosResponse): Promise<RiskGradeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskGradeDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskGradeDto[]>(null as any);
    }
}

export class RoadmapsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of roadmaps.
     */
    getRoadmaps( cancelToken?: CancelToken): Promise<RoadmapListDto[]> {
        let url_ = this.baseUrl + "/api/planning/roadmaps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoadmaps(_response);
        });
    }

    protected processGetRoadmaps(response: AxiosResponse): Promise<RoadmapListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoadmapListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoadmapListDto[]>(null as any);
    }

    /**
     * Create a roadmap.
     */
    create(request: CreateRoadmapRequest, cancelToken?: CancelToken): Promise<ObjectIdAndKey> {
        let url_ = this.baseUrl + "/api/planning/roadmaps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObjectIdAndKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<ObjectIdAndKey>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectIdAndKey>(null as any);
    }

    /**
     * Get roadmap details.
     */
    getRoadmap(idOrKey: string, cancelToken?: CancelToken): Promise<RoadmapDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoadmap(_response);
        });
    }

    protected processGetRoadmap(response: AxiosResponse): Promise<RoadmapDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoadmapDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoadmapDetailsDto>(null as any);
    }

    /**
     * Update a roadmap.
     */
    update(id: string, request: UpdateRoadmapRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a roadmap.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get roadmap items
     */
    getItems(idOrKey: string, cancelToken?: CancelToken): Promise<RoadmapItemListDto[]> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{idOrKey}/items";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetItems(_response);
        });
    }

    protected processGetItems(response: AxiosResponse): Promise<RoadmapItemListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoadmapItemListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoadmapItemListDto[]>(null as any);
    }

    /**
     * Get roadmap activities
     */
    getActivities(idOrKey: string, cancelToken?: CancelToken): Promise<RoadmapActivityListDto[]> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{idOrKey}/items/activities";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: AxiosResponse): Promise<RoadmapActivityListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoadmapActivityListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoadmapActivityListDto[]>(null as any);
    }

    /**
     * Get roadmap item details
     */
    getItem(roadmapIdOrKey: string, itemId: string, cancelToken?: CancelToken): Promise<RoadmapItemDetailsDto> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{roadmapIdOrKey}/items/{itemId}";
        if (roadmapIdOrKey === undefined || roadmapIdOrKey === null)
            throw new Error("The parameter 'roadmapIdOrKey' must be defined.");
        url_ = url_.replace("{roadmapIdOrKey}", encodeURIComponent("" + roadmapIdOrKey));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetItem(_response);
        });
    }

    protected processGetItem(response: AxiosResponse): Promise<RoadmapItemDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RoadmapItemDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoadmapItemDetailsDto>(null as any);
    }

    /**
     * Create a roadmap item of type: Activity, Timebox, Milestone.
     */
    createItem(roadmapId: string, request: CreateRoadmapItemRequest, cancelToken?: CancelToken): Promise<ObjectIdAndKey> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{roadmapId}/items";
        if (roadmapId === undefined || roadmapId === null)
            throw new Error("The parameter 'roadmapId' must be defined.");
        url_ = url_.replace("{roadmapId}", encodeURIComponent("" + roadmapId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateItem(_response);
        });
    }

    protected processCreateItem(response: AxiosResponse): Promise<ObjectIdAndKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<ObjectIdAndKey>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectIdAndKey>(null as any);
    }

    /**
     * Update a roadmap item of type: Activity, Timebox, Milestone.
     */
    updateItem(roadmapId: string, itemId: string, request: UpdateRoadmapItemRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{roadmapId}/items/{itemId}";
        if (roadmapId === undefined || roadmapId === null)
            throw new Error("The parameter 'roadmapId' must be defined.");
        url_ = url_.replace("{roadmapId}", encodeURIComponent("" + roadmapId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateItem(_response);
        });
    }

    protected processUpdateItem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a roadmap item.
     */
    deleteItem(roadmapId: string, itemId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{roadmapId}/items/{itemId}";
        if (roadmapId === undefined || roadmapId === null)
            throw new Error("The parameter 'roadmapId' must be defined.");
        url_ = url_.replace("{roadmapId}", encodeURIComponent("" + roadmapId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteItem(_response);
        });
    }

    protected processDeleteItem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reorganize a roadmap activity.
     */
    reorganizeActivity(roadmapId: string, activityId: string, request: ReorganizeRoadmapActivityRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/{roadmapId}/items/{activityId}/reorganize";
        if (roadmapId === undefined || roadmapId === null)
            throw new Error("The parameter 'roadmapId' must be defined.");
        url_ = url_.replace("{roadmapId}", encodeURIComponent("" + roadmapId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReorganizeActivity(_response);
        });
    }

    protected processReorganizeActivity(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of all visibility.
     */
    getVisibilityOptions( cancelToken?: CancelToken): Promise<VisibilityDto[]> {
        let url_ = this.baseUrl + "/api/planning/roadmaps/visibility-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVisibilityOptions(_response);
        });
    }

    protected processGetVisibilityOptions(response: AxiosResponse): Promise<VisibilityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<VisibilityDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisibilityDto[]>(null as any);
    }
}

export class TeamTypesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all team types.
     */
    getList( cancelToken?: CancelToken): Promise<TeamTypeDto[]> {
        let url_ = this.baseUrl + "/api/organization/team-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TeamTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamTypeDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamTypeDto[]>(null as any);
    }
}

export class WorkProcessesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of work processes.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<WorkProcessListDto[]> {
        let url_ = this.baseUrl + "/api/work/work-processes?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkProcessListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkProcessListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkProcessListDto[]>(null as any);
    }

    /**
     * Get work process details.
     */
    get(idOrKey: string, cancelToken?: CancelToken): Promise<WorkProcessDto> {
        let url_ = this.baseUrl + "/api/work/work-processes/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<WorkProcessDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkProcessDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkProcessDto>(null as any);
    }

    /**
     * Activate a work process.
     */
    activate(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/work-processes/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deactivate a work process.
     */
    deactivate(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/work-processes/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get work process schemes.
     */
    getSchemes(id: string, cancelToken?: CancelToken): Promise<WorkProcessSchemeDto[]> {
        let url_ = this.baseUrl + "/api/work/work-processes/{id}/schemes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchemes(_response);
        });
    }

    protected processGetSchemes(response: AxiosResponse): Promise<WorkProcessSchemeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkProcessSchemeDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkProcessSchemeDto[]>(null as any);
    }
}

export class WorkspacesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of workspaces.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<WorkspaceListDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkspaceListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkspaceListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkspaceListDto[]>(null as any);
    }

    /**
     * Get workspace details.
     */
    get(idOrKey: string, cancelToken?: CancelToken): Promise<WorkspaceDto> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<WorkspaceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkspaceDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkspaceDto>(null as any);
    }

    /**
     * Set the external view work item URL template for a workspace.
     */
    setExternalUrlTemplates(id: string, dto: SetExternalUrlTemplatesRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/workspaces/{id}/external-url-templates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetExternalUrlTemplates(_response);
        });
    }

    protected processSetExternalUrlTemplates(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get work items for a workspace.
     */
    getWorkItems(idOrKey: string, cancelToken?: CancelToken): Promise<WorkItemListDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}/work-items";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWorkItems(_response);
        });
    }

    protected processGetWorkItems(response: AxiosResponse): Promise<WorkItemListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemListDto[]>(null as any);
    }

    /**
     * Get work item details.
     */
    getWorkItem(idOrKey: string, workItemKey: string, cancelToken?: CancelToken): Promise<WorkItemDetailsDto> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}/work-items/{workItemKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        if (workItemKey === undefined || workItemKey === null)
            throw new Error("The parameter 'workItemKey' must be defined.");
        url_ = url_.replace("{workItemKey}", encodeURIComponent("" + workItemKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWorkItem(_response);
        });
    }

    protected processGetWorkItem(response: AxiosResponse): Promise<WorkItemDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemDetailsDto>(null as any);
    }

    /**
     * Get a work item's child work items.
     */
    getChildWorkItems(idOrKey: string, workItemKey: string, cancelToken?: CancelToken): Promise<WorkItemListDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}/work-items/{workItemKey}/children";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        if (workItemKey === undefined || workItemKey === null)
            throw new Error("The parameter 'workItemKey' must be defined.");
        url_ = url_.replace("{workItemKey}", encodeURIComponent("" + workItemKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChildWorkItems(_response);
        });
    }

    protected processGetChildWorkItems(response: AxiosResponse): Promise<WorkItemListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemListDto[]>(null as any);
    }

    /**
     * Get a work item's dependencies.
     */
    getWorkItemDependencies(idOrKey: string, workItemKey: string, cancelToken?: CancelToken): Promise<ScopedDependencyDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}/work-items/{workItemKey}/dependencies";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        if (workItemKey === undefined || workItemKey === null)
            throw new Error("The parameter 'workItemKey' must be defined.");
        url_ = url_.replace("{workItemKey}", encodeURIComponent("" + workItemKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWorkItemDependencies(_response);
        });
    }

    protected processGetWorkItemDependencies(response: AxiosResponse): Promise<ScopedDependencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ScopedDependencyDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopedDependencyDto[]>(null as any);
    }

    /**
     * Get metrics for a work item.
     */
    getMetrics(idOrKey: string, workItemKey: string, cancelToken?: CancelToken): Promise<WorkItemProgressDailyRollupDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces/{idOrKey}/work-items/{workItemKey}/metrics";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        if (workItemKey === undefined || workItemKey === null)
            throw new Error("The parameter 'workItemKey' must be defined.");
        url_ = url_.replace("{workItemKey}", encodeURIComponent("" + workItemKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetrics(_response);
        });
    }

    protected processGetMetrics(response: AxiosResponse): Promise<WorkItemProgressDailyRollupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemProgressDailyRollupDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemProgressDailyRollupDto[]>(null as any);
    }

    /**
     * Search for a work item using its key or title.
     * @param query (optional) 
     * @param top (optional) 
     */
    searchWorkItems(query: string | undefined, top: number | undefined, cancelToken?: CancelToken): Promise<WorkItemListDto[]> {
        let url_ = this.baseUrl + "/api/work/workspaces/work-items/search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "top=" + encodeURIComponent("" + top) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchWorkItems(_response);
        });
    }

    protected processSearchWorkItems(response: AxiosResponse): Promise<WorkItemListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemListDto[]>(null as any);
    }
}

export class WorkStatusCategoriesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all work status categories.
     */
    getList( cancelToken?: CancelToken): Promise<WorkStatusCategoryListDto[]> {
        let url_ = this.baseUrl + "/api/work/work-status-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkStatusCategoryListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkStatusCategoryListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkStatusCategoryListDto[]>(null as any);
    }
}

export class WorkStatusesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all work statuss.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<WorkStatusDto[]> {
        let url_ = this.baseUrl + "/api/work/work-statuses?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkStatusDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkStatusDto[]>(null as any);
    }

    /**
     * Create a work status.
     */
    create(request: CreateWorkStatusRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/work/work-statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get work status details using the id.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<WorkStatusDto> {
        let url_ = this.baseUrl + "/api/work/work-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<WorkStatusDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkStatusDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkStatusDto>(null as any);
    }

    /**
     * Update a work status.
     */
    update(id: number, request: UpdateWorkStatusRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/work-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WorkTypeLevelsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all work type levels.
     */
    getList( cancelToken?: CancelToken): Promise<WorkTypeLevelDto[]> {
        let url_ = this.baseUrl + "/api/work/work-type-levels";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkTypeLevelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkTypeLevelDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkTypeLevelDto[]>(null as any);
    }

    /**
     * Create a work type level.
     */
    create(request: CreateWorkTypeLevelRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/work/work-type-levels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get work type level details using the id.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<WorkTypeLevelDto> {
        let url_ = this.baseUrl + "/api/work/work-type-levels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<WorkTypeLevelDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkTypeLevelDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkTypeLevelDto>(null as any);
    }

    /**
     * Update a work type level.
     */
    update(id: number, request: UpdateWorkTypeLevelRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/work-type-levels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the order of portfolio tier work type levels.
     */
    updateOrder(request: UpdateWorkTypeLevelsOrderRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrder(_response);
        });
    }

    protected processUpdateOrder(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WorkTypesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all work types.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<WorkTypeDto[]> {
        let url_ = this.baseUrl + "/api/work/work-types?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkTypeDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkTypeDto[]>(null as any);
    }

    /**
     * Create a work type.
     */
    create(request: CreateWorkTypeRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/work/work-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get work type details using the id.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<WorkTypeDto> {
        let url_ = this.baseUrl + "/api/work/work-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<WorkTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkTypeDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkTypeDto>(null as any);
    }

    /**
     * Update a work type.
     */
    update(id: number, request: UpdateWorkTypeRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/work/work-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WorkTypeTiersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all work type tiers.
     */
    getList( cancelToken?: CancelToken): Promise<WorkTypeTierDto[]> {
        let url_ = this.baseUrl + "/api/work/work-type-tiers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WorkTypeTierDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkTypeTierDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkTypeTierDto[]>(null as any);
    }
}

export class EmployeesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all employees.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/organization/employees?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<EmployeeListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EmployeeListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmployeeListDto[]>(null as any);
    }

    /**
     * Create an employee.
     */
    create(request: CreateEmployeeRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/organization/employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get employee details using the key.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<EmployeeDetailsDto> {
        let url_ = this.baseUrl + "/api/organization/employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<EmployeeDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EmployeeDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmployeeDetailsDto>(null as any);
    }

    /**
     * Update an employee.
     */
    update(id: string, request: UpdateEmployeeRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a list of direct reports for an employee.
     */
    getDirectReports(id: string, cancelToken?: CancelToken): Promise<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/organization/employees/{id}/direct-reports";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDirectReports(_response);
        });
    }

    protected processGetDirectReports(response: AxiosResponse): Promise<EmployeeListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EmployeeListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmployeeListDto[]>(null as any);
    }

    /**
     * Remove invalid employee record from employee list.
     */
    removeInvalid(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/employees/{id}/remove-invalid";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveInvalid(_response);
        });
    }

    protected processRemoveInvalid(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TeamsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of teams.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<TeamListDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TeamListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamListDto[]>(null as any);
    }

    /**
     * Create a team.
     */
    create(request: CreateTeamRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/organization/teams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get team details using the key.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<TeamDetailsDto> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TeamDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamDetailsDto>(null as any);
    }

    /**
     * Update a team.
     */
    update(id: string, request: UpdateTeamRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deactivate a team.
     */
    deactivate(id: string, request: DeactivateTeamRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get parent team memberships.
     */
    getTeamMemberships(id: string, cancelToken?: CancelToken): Promise<TeamMembershipDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/team-memberships";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamMemberships(_response);
        });
    }

    protected processGetTeamMemberships(response: AxiosResponse): Promise<TeamMembershipDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamMembershipDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamMembershipDto[]>(null as any);
    }

    /**
     * Add a parent team membership.
     */
    addTeamMembership(id: string, request: AddTeamMembershipRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/team-memberships";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTeamMembership(_response);
        });
    }

    protected processAddTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update a team membership.
     */
    updateTeamMembership(id: string, teamMembershipId: string, request: UpdateTeamMembershipRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/team-memberships/{teamMembershipId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamMembershipId === undefined || teamMembershipId === null)
            throw new Error("The parameter 'teamMembershipId' must be defined.");
        url_ = url_.replace("{teamMembershipId}", encodeURIComponent("" + teamMembershipId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTeamMembership(_response);
        });
    }

    protected processUpdateTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove a parent team membership.
     */
    removeTeamMembership(id: string, teamMembershipId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/team-memberships/{teamMembershipId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamMembershipId === undefined || teamMembershipId === null)
            throw new Error("The parameter 'teamMembershipId' must be defined.");
        url_ = url_.replace("{teamMembershipId}", encodeURIComponent("" + teamMembershipId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveTeamMembership(_response);
        });
    }

    protected processRemoveTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get the backlog for a team.
     */
    getTeamBacklog(idOrCode: string, cancelToken?: CancelToken): Promise<WorkItemBacklogItemDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams/{idOrCode}/backlog";
        if (idOrCode === undefined || idOrCode === null)
            throw new Error("The parameter 'idOrCode' must be defined.");
        url_ = url_.replace("{idOrCode}", encodeURIComponent("" + idOrCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamBacklog(_response);
        });
    }

    protected processGetTeamBacklog(response: AxiosResponse): Promise<WorkItemBacklogItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WorkItemBacklogItemDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkItemBacklogItemDto[]>(null as any);
    }

    /**
     * Get the active dependencies for a team.
     */
    getTeamDependencies(id: string, cancelToken?: CancelToken): Promise<DependencyDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/dependencies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamDependencies(_response);
        });
    }

    protected processGetTeamDependencies(response: AxiosResponse): Promise<DependencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DependencyDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DependencyDto[]>(null as any);
    }

    /**
     * Get team risks.
     * @param includeClosed (optional) 
     */
    getRisks(id: string, includeClosed: boolean | undefined, cancelToken?: CancelToken): Promise<RiskListDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/risks?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeClosed === null)
            throw new Error("The parameter 'includeClosed' cannot be null.");
        else if (includeClosed !== undefined)
            url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRisks(_response);
        });
    }

    protected processGetRisks(response: AxiosResponse): Promise<RiskListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskListDto[]>(null as any);
    }

    /**
     * Create a risk for a team.
     */
    createRisk(id: string, request: CreateRiskRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/risks";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRisk(_response);
        });
    }

    protected processCreateRisk(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get a team risk by Id.
     */
    getRiskById(id: string, riskIdOrKey: string, cancelToken?: CancelToken): Promise<RiskDetailsDto> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/risks/{riskIdOrKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (riskIdOrKey === undefined || riskIdOrKey === null)
            throw new Error("The parameter 'riskIdOrKey' must be defined.");
        url_ = url_.replace("{riskIdOrKey}", encodeURIComponent("" + riskIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRiskById(_response);
        });
    }

    protected processGetRiskById(response: AxiosResponse): Promise<RiskDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskDetailsDto>(null as any);
    }

    /**
     * Update a team risk.
     */
    updateRisk(id: string, riskId: string, request: UpdateRiskRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams/{id}/risks/{riskId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (riskId === undefined || riskId === null)
            throw new Error("The parameter 'riskId' must be defined.");
        url_ = url_.replace("{riskId}", encodeURIComponent("" + riskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRisk(_response);
        });
    }

    protected processUpdateRisk(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get the functional organizaation chart for a given date.
     * @param asOfDate (optional) 
     */
    getFunctionalOrganizationChart(asOfDate: Date | null | undefined, cancelToken?: CancelToken): Promise<FunctionalOrganizationChartDto> {
        let url_ = this.baseUrl + "/api/organization/teams/functional-organization-chart?";
        if (asOfDate !== undefined && asOfDate !== null)
            url_ += "asOfDate=" + encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFunctionalOrganizationChart(_response);
        });
    }

    protected processGetFunctionalOrganizationChart(response: AxiosResponse): Promise<FunctionalOrganizationChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FunctionalOrganizationChartDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FunctionalOrganizationChartDto>(null as any);
    }
}

export class TeamsOfTeamsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of team of teams.
     * @param includeInactive (optional) 
     */
    getList(includeInactive: boolean | undefined, cancelToken?: CancelToken): Promise<TeamOfTeamsListDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TeamOfTeamsListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamOfTeamsListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamOfTeamsListDto[]>(null as any);
    }

    /**
     * Create a team of teams.
     */
    create(request: CreateTeamOfTeamsRequest, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<number>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get team of teams details using the key.
     */
    getById(id: number, cancelToken?: CancelToken): Promise<TeamOfTeamsDetailsDto> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TeamOfTeamsDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamOfTeamsDetailsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamOfTeamsDetailsDto>(null as any);
    }

    /**
     * Update a team of teams.
     */
    update(id: string, request: UpdateTeamOfTeamsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deactivate a team of teams.
     */
    deactivate(id: string, request: DeactivateTeamOfTeamsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get parent team memberships.
     */
    getTeamMemberships(id: string, cancelToken?: CancelToken): Promise<TeamMembershipDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/team-memberships";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamMemberships(_response);
        });
    }

    protected processGetTeamMemberships(response: AxiosResponse): Promise<TeamMembershipDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TeamMembershipDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamMembershipDto[]>(null as any);
    }

    /**
     * Add a parent team membership.
     */
    addTeamMembership(id: string, request: AddTeamMembershipRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/team-memberships";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTeamMembership(_response);
        });
    }

    protected processAddTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update a team membership.
     */
    updateTeamMembership(id: string, teamMembershipId: string, request: UpdateTeamMembershipRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/team-memberships/{teamMembershipId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamMembershipId === undefined || teamMembershipId === null)
            throw new Error("The parameter 'teamMembershipId' must be defined.");
        url_ = url_.replace("{teamMembershipId}", encodeURIComponent("" + teamMembershipId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTeamMembership(_response);
        });
    }

    protected processUpdateTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove a parent team membership.
     */
    removeTeamMembership(id: string, teamMembershipId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/team-memberships/{teamMembershipId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (teamMembershipId === undefined || teamMembershipId === null)
            throw new Error("The parameter 'teamMembershipId' must be defined.");
        url_ = url_.replace("{teamMembershipId}", encodeURIComponent("" + teamMembershipId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveTeamMembership(_response);
        });
    }

    protected processRemoveTeamMembership(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get team risks.
     * @param includeClosed (optional) 
     */
    getRisks(id: string, includeClosed: boolean | undefined, cancelToken?: CancelToken): Promise<RiskListDto[]> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/risks?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeClosed === null)
            throw new Error("The parameter 'includeClosed' cannot be null.");
        else if (includeClosed !== undefined)
            url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRisks(_response);
        });
    }

    protected processGetRisks(response: AxiosResponse): Promise<RiskListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskListDto[]>(null as any);
    }

    /**
     * Create a risk for a team of teams.
     */
    createRisk(id: string, request: CreateRiskRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/risks";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRisk(_response);
        });
    }

    protected processCreateRisk(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get a team of teams risk by Id.
     */
    getRiskById(id: string, riskIdOrKey: string, cancelToken?: CancelToken): Promise<RiskDetailsDto> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/risks/{riskIdOrKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (riskIdOrKey === undefined || riskIdOrKey === null)
            throw new Error("The parameter 'riskIdOrKey' must be defined.");
        url_ = url_.replace("{riskIdOrKey}", encodeURIComponent("" + riskIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRiskById(_response);
        });
    }

    protected processGetRiskById(response: AxiosResponse): Promise<RiskDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskDetailsDto>(null as any);
    }

    /**
     * Update a team of teams risk.
     */
    updateRisk(id: string, riskId: string, request: UpdateRiskRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/organization/teams-of-teams/{id}/risks/{riskId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (riskId === undefined || riskId === null)
            throw new Error("The parameter 'riskId' must be defined.");
        url_ = url_.replace("{riskId}", encodeURIComponent("" + riskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRisk(_response);
        });
    }

    protected processUpdateRisk(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LinksClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of links for a specific objectId.
     */
    getList(objectId: string, cancelToken?: CancelToken): Promise<LinkDto[]> {
        let url_ = this.baseUrl + "/api/links/{objectId}/list";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{objectId}", encodeURIComponent("" + objectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<LinkDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LinkDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LinkDto[]>(null as any);
    }

    /**
     * Get a link by id.
     */
    getById(id: string, cancelToken?: CancelToken): Promise<LinkDto> {
        let url_ = this.baseUrl + "/api/links/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<LinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LinkDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LinkDto>(null as any);
    }

    /**
     * Update a link.
     */
    update(id: string, request: UpdateLinkRequest, cancelToken?: CancelToken): Promise<LinkDto> {
        let url_ = this.baseUrl + "/api/links/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<LinkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LinkDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LinkDto>(null as any);
    }

    /**
     * Delete a link.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/links/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a link.
     */
    create(request: CreateLinkRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/links";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class HealthChecksClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a health check by id.
     */
    getById(id: string, cancelToken?: CancelToken): Promise<HealthCheckDto> {
        let url_ = this.baseUrl + "/api/healthchecks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<HealthCheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<HealthCheckDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HealthCheckDto>(null as any);
    }

    /**
     * Update a health report.
     */
    update(id: string, request: UpdateHealthCheckRequest, cancelToken?: CancelToken): Promise<HealthCheckDto> {
        let url_ = this.baseUrl + "/api/healthchecks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<HealthCheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<HealthCheckDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HealthCheckDto>(null as any);
    }

    /**
     * Get the health report for a specific objectId.
     */
    getHealthReport(objectId: string, cancelToken?: CancelToken): Promise<HealthCheckDto[]> {
        let url_ = this.baseUrl + "/api/healthchecks/health-report/{objectId}";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{objectId}", encodeURIComponent("" + objectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHealthReport(_response);
        });
    }

    protected processGetHealthReport(response: AxiosResponse): Promise<HealthCheckDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<HealthCheckDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HealthCheckDto[]>(null as any);
    }

    /**
     * Create a health report.
     */
    create(request: CreateHealthCheckRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/healthchecks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get a list of health check statuses.
     */
    getStatuses( cancelToken?: CancelToken): Promise<HealthStatusDto[]> {
        let url_ = this.baseUrl + "/api/healthchecks/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatuses(_response);
        });
    }

    protected processGetStatuses(response: AxiosResponse): Promise<HealthStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<HealthStatusDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HealthStatusDto[]>(null as any);
    }
}

export class AzureDevOpsBoardsConnectionsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all Azure DevOps Boards connections.
     * @param includeDisabled (optional) 
     */
    getList(includeDisabled: boolean | undefined, cancelToken?: CancelToken): Promise<ConnectionListDto[]> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections?";
        if (includeDisabled === null)
            throw new Error("The parameter 'includeDisabled' cannot be null.");
        else if (includeDisabled !== undefined)
            url_ += "includeDisabled=" + encodeURIComponent("" + includeDisabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ConnectionListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ConnectionListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectionListDto[]>(null as any);
    }

    /**
     * Create an Azure DevOps Boards connection.
     */
    create(request: CreateAzureDevOpsBoardConnectionRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<string>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get Azure DevOps Boards connection based on id.
     */
    getById(id: string, cancelToken?: CancelToken): Promise<AzureDevOpsBoardsConnectionDetailsDto> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AzureDevOpsBoardsConnectionDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AzureDevOpsBoardsConnectionDetailsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AzureDevOpsBoardsConnectionDetailsDto>(null as any);
    }

    /**
     * Update an Azure DevOps Boards connection.
     */
    update(id: string, request: UpdateAzureDevOpsBoardConnectionRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete an Azure DevOps Boards connection.
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update an Azure DevOps Boards connection sync state.
     * @param isSyncEnabled (optional) 
     */
    updateSyncState(id: string, isSyncEnabled: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/sync-state?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (isSyncEnabled === null)
            throw new Error("The parameter 'isSyncEnabled' cannot be null.");
        else if (isSyncEnabled !== undefined)
            url_ += "isSyncEnabled=" + encodeURIComponent("" + isSyncEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSyncState(_response);
        });
    }

    protected processUpdateSyncState(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Azure DevOps connection teams based on id.
     * @param workspaceId (optional) 
     */
    getConnectionTeams(id: string, workspaceId: string | null | undefined, cancelToken?: CancelToken): Promise<AzureDevOpsBoardsWorkspaceTeamDto[]> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/teams?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workspaceId !== undefined && workspaceId !== null)
            url_ += "workspaceId=" + encodeURIComponent("" + workspaceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectionTeams(_response);
        });
    }

    protected processGetConnectionTeams(response: AxiosResponse): Promise<AzureDevOpsBoardsWorkspaceTeamDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AzureDevOpsBoardsWorkspaceTeamDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AzureDevOpsBoardsWorkspaceTeamDto[]>(null as any);
    }

    /**
     * Update Azure DevOps connection team mappings.
     */
    mapConnectionTeams(id: string, request: AzdoConnectionTeamMappingsRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/teams";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMapConnectionTeams(_response);
        });
    }

    protected processMapConnectionTeams(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Test Azure DevOps Boards connection configuration.
     */
    testConfig(request: TestAzureDevOpsBoardConnectionRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTestConfig(_response);
        });
    }

    protected processTestConfig(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sync Azure DevOps processes and projects.
     */
    syncOrganizationConfiguration(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/sync-organization-configuration";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncOrganizationConfiguration(_response);
        });
    }

    protected processSyncOrganizationConfiguration(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Initialize Azure DevOps project integration as a Moda workspace.
     */
    initWorkProcesssIntegration(id: string, request: InitWorkProcessIntegrationRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/init-work-process-integration";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInitWorkProcesssIntegration(_response);
        });
    }

    protected processInitWorkProcesssIntegration(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Initialize Azure DevOps project integration as a Moda workspace.
     */
    initWorkspaceIntegration(id: string, request: InitWorkspaceIntegrationRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app-integrations/azure-devops-boards-connections/{id}/init-workspace-integration";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInitWorkspaceIntegration(_response);
        });
    }

    protected processInitWorkspaceIntegration(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ConnectorsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all connectors.
     */
    getList( cancelToken?: CancelToken): Promise<ConnectorListDto[]> {
        let url_ = this.baseUrl + "/api/app-integrations/connectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ConnectorListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ConnectorListDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectorListDto[]>(null as any);
    }
}

export class BackgroundJobsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get a list of all job types.
     */
    getJobTypes( cancelToken?: CancelToken): Promise<BackgroundJobTypeDto[]> {
        let url_ = this.baseUrl + "/api/admin/background-jobs/job-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJobTypes(_response);
        });
    }

    protected processGetJobTypes(response: AxiosResponse): Promise<BackgroundJobTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BackgroundJobTypeDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BackgroundJobTypeDto[]>(null as any);
    }

    /**
     * Get a list of running jobs.
     */
    getRunningJobs( cancelToken?: CancelToken): Promise<BackgroundJobDto[]> {
        let url_ = this.baseUrl + "/api/admin/background-jobs/running";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRunningJobs(_response);
        });
    }

    protected processGetRunningJobs(response: AxiosResponse): Promise<BackgroundJobDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BackgroundJobDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BackgroundJobDto[]>(null as any);
    }

    /**
     * Run a background job.
     * @param jobTypeId (optional) 
     */
    run(jobTypeId: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/background-jobs/run?";
        if (jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' cannot be null.");
        else if (jobTypeId !== undefined)
            url_ += "jobTypeId=" + encodeURIComponent("" + jobTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a recurring background job.
     */
    create(request: CreateRecurringJobRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/background-jobs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ApplicationPermission {
    description?: string;
    action?: string;
    resource?: string;
    isBasic?: boolean;
    isRoot?: boolean;
    name?: string;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface UserDetailsDto {
    id?: string;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    isActive?: boolean;
    phoneNumber?: string | undefined;
    employee?: NavigationDto | undefined;
}

export interface NavigationDtoOfGuidAndInteger {
    id?: string;
    key?: number;
    name?: string;
}

export interface NavigationDto extends NavigationDtoOfGuidAndInteger {
}

export interface HttpValidationProblemDetails extends ProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export interface UpdateProfileRequest {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber?: string | undefined;
}

export interface AuditDto {
    id?: string;
    userId?: string;
    type?: string | undefined;
    tableName?: string | undefined;
    dateTime?: Date;
    oldValues?: string | undefined;
    newValues?: string | undefined;
    affectedColumns?: string | undefined;
    primaryKey?: string | undefined;
}

export interface RoleListDto {
    id?: string;
    name?: string;
    description?: string | undefined;
}

export interface RoleDto {
    id?: string;
    name?: string;
    description?: string | undefined;
    permissions?: string[] | undefined;
}

export interface UpdateRolePermissionsRequest {
    roleId: string;
    permissions: string[];
}

export interface CreateOrUpdateRoleRequest {
    id?: string | undefined;
    name: string;
    description?: string | undefined;
}

export interface UserRoleDto {
    roleId?: string | undefined;
    roleName?: string | undefined;
    description?: string | undefined;
    enabled?: boolean;
}

export interface AssignUserRolesRequest {
    userId?: string;
    userRoles?: UserRoleDto[];
}

export interface ToggleUserStatusRequest {
    userId?: string;
    activateUser?: boolean;
}

export interface StrategicThemeListDto {
    id?: string;
    key?: number;
    name?: string;
    state?: SimpleNavigationDto;
}

export interface SimpleNavigationDto {
    id?: number;
    name?: string;
}

export interface StrategicThemeDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string;
    state?: SimpleNavigationDto;
}

export interface ObjectIdAndKey {
    id?: string;
    key?: number;
}

export interface CreateStrategicThemeRequest {
    /** The name of the strategic theme, highlighting its focus or priority. */
    name: string;
    /** A detailed description of the strategic theme and its importance. */
    description: string;
    /** The current lifecycle state of the strategic theme (e.g., Active, Proposed, Archived). */
    stateId?: number;
}

export interface UpdateStrategicThemeRequest {
    /** The unique identifier of the strategic theme. */
    id: string;
    /** The name of the strategic theme, highlighting its focus or priority. */
    name: string;
    /** A detailed description of the strategic theme and its importance. */
    description: string;
    /** The current lifecycle state of the strategic theme (e.g., Active, Proposed, Archived). */
    stateId?: number;
}

export interface CommonEnumDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface StrategicThemeStateDto extends CommonEnumDto {
}

export interface StrategyListDto {
    id?: string;
    key?: number;
    name?: string;
    status?: SimpleNavigationDto;
    start?: Date | undefined;
    end?: Date | undefined;
}

export interface StrategyDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string;
    status?: SimpleNavigationDto;
    start?: Date | undefined;
    end?: Date | undefined;
}

export interface CreateStrategyRequest {
    /** The concise statement describing the strategy and its purpose or focus area. */
    name: string;
    /** A concise statement describing the strategy of the organization. */
    description?: string;
    /** The current status id of the strategy. */
    statusId?: number;
    /** The start date of when the strategy became active. */
    start?: Date | undefined;
    /** The end date of when the strategy became archived. */
    end?: Date | undefined;
}

export interface UpdateStrategyRequest {
    /** The unique identifier of the strategy. */
    id: string;
    /** The concise statement describing the strategy and its purpose or focus area. */
    name: string;
    /** A concise statement describing the strategy of the organization. */
    description?: string;
    /** The current status id of the strategy. */
    statusId?: number;
    /** The start date of when the strategy became active. */
    start?: Date | undefined;
    /** The end date of when the strategy became archived. */
    end?: Date | undefined;
}

export interface StrategyStatusDto extends CommonEnumDto {
}

export interface VisionDto {
    id?: string;
    key?: number;
    description?: string;
    state?: SimpleNavigationDto;
    start?: Date | undefined;
    end?: Date | undefined;
}

export interface CreateVisionRequest {
    /** A concise statement describing the vision of the organization. */
    description: string;
}

export interface UpdateVisionRequest {
    /** The unique identifier of the vision. */
    id: string;
    /** A concise statement describing the vision of the organization. */
    description: string;
}

export interface VisionStateDto extends CommonEnumDto {
}

export interface PlanningIntervalListDto {
    id?: string;
    key?: number;
    name?: string;
    start?: Date;
    end?: Date;
    state?: string;
}

export interface PlanningIntervalDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string | undefined;
    start?: Date;
    end?: Date;
    state?: string;
    objectivesLocked?: boolean;
    predictability?: number | undefined;
}

export interface PlanningIntervalCalendarDto {
    id?: string;
    key?: number;
    name?: string;
    start?: Date;
    end?: Date;
    iterationSchedules?: LocalScheduleDto[];
}

export interface LocalScheduleDto {
    id?: string;
    key?: number;
    name?: string;
    start?: Date;
    end?: Date;
}

export interface PlanningIntervalPredictabilityDto {
    predictability?: number | undefined;
    teamPredictabilities?: PlanningIntervalTeamPredictabilityDto[];
}

export interface PlanningIntervalTeamPredictabilityDto {
    team?: PlanningTeamNavigationDto;
    predictability?: number | undefined;
}

export interface PlanningTeamNavigationDto extends NavigationDto {
    type?: string;
}

export interface CreatePlanningIntervalRequest {
    /** Gets the team name. */
    name: string;
    /** Gets the team description. */
    description?: string | undefined;
    /** Gets or sets the start. */
    start: Date;
    /** Gets or sets the end. */
    end: Date;
    /** Gets or sets the length of iterations in weeks. */
    iterationWeeks?: number;
    /** Gets or sets the iteration prefix. */
    iterationPrefix?: string | undefined;
}

export interface UpdatePlanningIntervalRequest {
    /** Gets or sets the identifier. */
    id?: string;
    /** Gets the team name. */
    name: string;
    /** Gets the team description. */
    description?: string | undefined;
    /** Gets or sets the objectives locked. */
    objectivesLocked?: boolean;
}

export interface PlanningIntervalTeamResponse {
    /** Gets or sets the identifier. */
    id?: string;
    /** Gets the key. */
    key?: number;
    /** The name of the workspace. */
    name?: string;
    /** Gets the code. */
    code?: string;
    /** Gets the team type. */
    type?: string;
    /** Indicates whether the organization is active or not.   */
    isActive?: boolean;
    teamOfTeams?: TeamNavigationDto | undefined;
}

export interface TeamNavigationDto extends NavigationDto {
    type?: string;
}

export interface ManagePlanningIntervalDatesRequest {
    id: string;
    /** Gets or sets the start. */
    start: Date;
    /** Gets or sets the end. */
    end: Date;
    /** The iterations for the Planning Interval. */
    iterations?: PlanningIntervalIterationUpsertRequest[];
}

export interface PlanningIntervalIterationUpsertRequest {
    iterationId?: string | undefined;
    /** The name of the iteration. */
    name: string;
    /** The type of iteration. */
    typeId?: number;
    /** Gets or sets the start. */
    start: Date;
    /** Gets or sets the end. */
    end: Date;
}

export interface ManagePlanningIntervalTeamsRequest {
    id?: string;
    teamIds?: string[];
}

export interface PlanningIntervalIterationListDto {
    id?: string;
    key?: number;
    name?: string;
    start?: Date;
    end?: Date;
    type?: SimpleNavigationDto;
}

export interface PlanningIntervalIterationTypeDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface PlanningIntervalObjectiveListDto {
    id?: string;
    key?: number;
    name?: string;
    status?: SimpleNavigationDto;
    healthCheck?: PlanningHealthCheckDto | undefined;
    planningInterval?: NavigationDto;
    team?: PlanningTeamNavigationDto;
    progress?: number;
    type?: SimpleNavigationDto;
    startDate?: Date | undefined;
    targetDate?: Date | undefined;
    isStretch?: boolean;
    order?: number | undefined;
}

export interface PlanningHealthCheckDto {
    id?: string;
    status?: SimpleNavigationDto;
    expiration?: Date;
}

export interface PlanningIntervalObjectiveDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string | undefined;
    status?: SimpleNavigationDto;
    healthCheck?: PlanningHealthCheckDto | undefined;
    progress?: number;
    planningInterval?: NavigationDto;
    team?: PlanningTeamNavigationDto;
    type?: SimpleNavigationDto;
    startDate?: Date | undefined;
    targetDate?: Date | undefined;
    closedDate?: Date | undefined;
    isStretch?: boolean;
}

export interface CreatePlanningIntervalObjectiveRequest {
    planningIntervalId?: string;
    teamId: string;
    name: string;
    description?: string | undefined;
    startDate?: Date | undefined;
    targetDate?: Date | undefined;
    isStretch?: boolean;
    order?: number | undefined;
}

export interface UpdatePlanningIntervalObjectiveRequest {
    planningIntervalId?: string;
    objectiveId?: string;
    name: string;
    description?: string | undefined;
    statusId?: number;
    progress?: number;
    startDate?: Date | undefined;
    targetDate?: Date | undefined;
    isStretch?: boolean;
}

export interface UpdatePlanningIntervalObjectivesOrderRequest {
    planningIntervalId?: string;
    objectives?: { [key: string]: number; };
}

export interface PlanningIntervalObjectiveHealthCheckDto {
    /** Gets or sets the identifier. */
    id?: string;
    /** Gets the key. */
    key?: number;
    /** The name of the objective. */
    name?: string;
    /** Gets or sets the status. */
    status?: SimpleNavigationDto;
    /** Gets or sets the type. */
    type?: SimpleNavigationDto;
    planningInterval?: NavigationDto;
    team?: PlanningTeamNavigationDto;
    progress?: number;
    /** Gets a value indicating whether this instance is stretch. */
    isStretch?: boolean;
    /** The id of the health check. */
    healthCheckId?: string | undefined;
    /** The status of the health check. */
    healthStatus?: SimpleNavigationDto | undefined;
    /** The timestamp of when the health check was initially created. */
    reportedOn?: Date | undefined;
    /** The expiration of the health check. */
    expiration?: Date | undefined;
    /** The note for the health check. */
    note?: string | undefined;
}

export interface WorkItemsSummaryDto {
    progressSummary?: WorkItemProgressRollupDto;
    workItems?: WorkItemListDto[];
}

export interface WorkItemProgressRollupDto {
    proposed?: number;
    active?: number;
    done?: number;
    total?: number;
}

export interface WorkItemListDto {
    id?: string;
    key?: string;
    title?: string;
    workspace?: WorkspaceNavigationDto;
    type?: string;
    status?: string;
    statusCategory?: SimpleNavigationDto;
    parent?: WorkItemNavigationDto | undefined;
    team?: WorkTeamNavigationDto | undefined;
    assignedTo?: EmployeeNavigationDto | undefined;
    stackRank?: number;
    externalViewWorkItemUrl?: string | undefined;
}

export interface NavigationDtoOfGuidAndString {
    id?: string;
    key?: string | undefined;
    name?: string;
}

export interface WorkspaceNavigationDto extends NavigationDtoOfGuidAndString {
}

export interface WorkItemNavigationDto {
    id?: string;
    key?: string;
    title?: string;
    workspaceKey?: string;
    externalViewWorkItemUrl?: string | undefined;
}

export interface WorkTeamNavigationDto extends NavigationDto {
    type?: string;
}

export interface EmployeeNavigationDto extends NavigationDto {
}

export interface WorkItemProgressDailyRollupDto extends WorkItemProgressRollupDto {
    date?: Date;
}

export interface ManagePlanningIntervalObjectiveWorkItemsRequest {
    planningIntervalId?: string;
    objectiveId?: string;
    workItemIds?: string[];
}

export interface PlanningIntervalObjectiveStatusDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface RiskListDto {
    id?: string;
    key?: number;
    summary?: string;
    team?: PlanningTeamNavigationDto | undefined;
    reportedOn?: Date;
    status?: string;
    category?: string;
    exposure?: string;
    assignee?: EmployeeNavigationDto | undefined;
    followUpDate?: Date | undefined;
}

export interface RiskDetailsDto {
    id?: string;
    key?: number;
    summary?: string;
    description?: string | undefined;
    team?: PlanningTeamNavigationDto | undefined;
    reportedOn?: Date;
    reportedBy?: NavigationDto;
    status?: SimpleNavigationDto;
    category?: SimpleNavigationDto;
    impact?: SimpleNavigationDto;
    likelihood?: SimpleNavigationDto;
    exposure?: SimpleNavigationDto;
    assignee?: NavigationDto | undefined;
    followUpDate?: Date | undefined;
    response?: string | undefined;
    closedDate?: Date | undefined;
}

export interface CreateRiskRequest {
    teamId: string;
    summary: string;
    description?: string | undefined;
    categoryId?: number;
    impactId?: number;
    likelihoodId?: number;
    assigneeId?: string | undefined;
    followUpDate?: Date | undefined;
    response?: string | undefined;
}

export interface UpdateRiskRequest {
    riskId?: string;
    teamId: string;
    summary: string;
    description?: string | undefined;
    statusId?: number;
    categoryId?: number;
    impactId?: number;
    likelihoodId?: number;
    assigneeId?: string | undefined;
    followUpDate?: Date | undefined;
    response?: string | undefined;
}

export interface RiskStatusDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface RiskCategoryDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface RiskGradeDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface RoadmapListDto {
    id?: string;
    key?: number;
    name?: string;
    start?: Date;
    end?: Date;
    visibility?: SimpleNavigationDto;
    color?: string | undefined;
    roadmapManagers?: EmployeeNavigationDto[];
}

export interface RoadmapDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string | undefined;
    start?: Date;
    end?: Date;
    visibility?: SimpleNavigationDto;
    roadmapManagers?: EmployeeNavigationDto[];
}

export interface CreateRoadmapRequest {
    /** The name of the Roadmap. */
    name: string;
    /** The description of the Roadmap. */
    description?: string | undefined;
    /** The Roadmap start date. */
    start: Date;
    /** The Roadmap end date. */
    end: Date;
    /** The managers of the Roadmap. */
    roadmapManagerIds: string[];
    /** The visibility id for the Roadmap. If the Roadmap is public, all users can see the Roadmap. Otherwise, only the Roadmap Managers can see the Roadmap. */
    visibilityId?: number;
}

export interface UpdateRoadmapRequest {
    /** The unique identifier of the Roadmap. */
    id: string;
    /** The name of the Roadmap. */
    name: string;
    /** The description of the Roadmap. */
    description?: string | undefined;
    /** The Roadmap start date. */
    start: Date;
    /** The Roadmap end date. */
    end: Date;
    /** The managers of the Roadmap. */
    roadmapManagerIds: string[];
    /** The visibility id for the Roadmap. If the Roadmap is public, all users can see the Roadmap. Otherwise, only the Roadmap Managers can see the Roadmap. */
    visibilityId?: number;
}

export interface RoadmapItemListDto {
    id?: string;
    roadmapId?: string;
    name?: string;
    type?: SimpleNavigationDto;
    parent?: RoadmapActivityNavigationDto | undefined;
    color?: string | undefined;
    $type: string;
}

export interface RoadmapActivityNavigationDto {
    id?: string;
    name?: string;
}

export interface RoadmapActivityListDto extends RoadmapItemListDto {
    start?: Date;
    end?: Date;
    order?: number;
    children?: RoadmapItemListDto[];
}

export interface RoadmapMilestoneListDto extends RoadmapItemListDto {
    date?: Date;
}

export interface RoadmapTimeboxListDto extends RoadmapItemListDto {
    start?: Date;
    end?: Date;
}

export interface RoadmapItemDetailsDto {
    id?: string;
    roadmapId?: string;
    name?: string;
    description?: string | undefined;
    type?: SimpleNavigationDto;
    parent?: RoadmapActivityNavigationDto | undefined;
    color?: string | undefined;
    $type: string;
}

export interface RoadmapActivityDetailsDto extends RoadmapItemDetailsDto {
    start?: Date;
    end?: Date;
    order?: number;
    children?: RoadmapItemDetailsDto[];
}

export interface RoadmapMilestoneDetailsDto extends RoadmapItemDetailsDto {
    date?: Date;
}

export interface RoadmapTimeboxDetailsDto extends RoadmapItemDetailsDto {
    start?: Date;
    end?: Date;
}

export interface CreateRoadmapItemRequest {
    /** The Roadmap Id the Roadmap Item belongs to. */
    roadmapId: string;
    /** The name of the Roadmap Item. */
    name: string;
    /** The description of the Roadmap Item. */
    description?: string | undefined;
    /** The parent Roadmap Item Id. This is used to connect Roadmap Items together. */
    parentId?: string | undefined;
    /** The color of the Roadmap Item. This is used to display the Roadmap Item in the UI. */
    color?: string | undefined;
    $type: string;
}

export interface CreateRoadmapActivityRequest extends CreateRoadmapItemRequest {
    /** The Activity start date. */
    start?: Date;
    /** The Activity end date. */
    end?: Date;
}

export interface CreateRoadmapMilestoneRequest extends CreateRoadmapItemRequest {
    /** The Milestone date. */
    date?: Date;
}

export interface CreateRoadmapTimeboxRequest extends CreateRoadmapItemRequest {
    /** The Timebox start date. */
    start?: Date;
    /** The Timebox end date. */
    end?: Date;
}

export interface UpdateRoadmapItemRequest {
    /** The Roadmap Id the Roadmap Item belongs to. */
    roadmapId: string;
    /** The Roadmap Item Id. */
    itemId: string;
    /** The name of the Roadmap Item. */
    name: string;
    /** The description of the Roadmap Item. */
    description?: string | undefined;
    /** The parent Roadmap Item Id. This is used to connect Roadmap Items together. */
    parentId?: string | undefined;
    /** The color of the Roadmap Item. This is used to display the Roadmap Item in the UI. */
    color?: string | undefined;
    $type: string;
}

export interface UpdateRoadmapActivityRequest extends UpdateRoadmapItemRequest {
    /** The Roadmap Item start date. */
    start?: Date;
    /** The Roadmap Item end date. */
    end?: Date;
}

export interface UpdateRoadmapMilestoneRequest extends UpdateRoadmapItemRequest {
    /** The Milestone date. */
    date?: Date;
}

export interface UpdateRoadmapTimeboxRequest extends UpdateRoadmapItemRequest {
    /** The Roadmap Item start date. */
    start?: Date;
    /** The Roadmap Item end date. */
    end?: Date;
}

export interface ReorganizeRoadmapActivityRequest {
    roadmapId: string;
    parentActivityId?: string | undefined;
    activityId: string;
    order?: number;
}

export interface VisibilityDto extends CommonEnumDto {
}

export interface TeamTypeDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface WorkProcessListDto {
    id?: string;
    key?: number;
    name?: string;
    ownership?: SimpleNavigationDto;
    isActive?: boolean;
}

export interface WorkProcessDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string | undefined;
    ownership?: SimpleNavigationDto;
    isActive?: boolean;
}

export interface WorkProcessSchemeDto {
    id?: string;
    workType?: WorkTypeDto;
    workflow?: WorkflowDto;
    isActive?: boolean;
}

export interface WorkTypeDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    level?: SimpleNavigationDto;
    isActive?: boolean;
}

export interface WorkflowDto {
    id?: string;
    key?: number;
    name?: string;
    description?: string | undefined;
    ownership?: SimpleNavigationDto;
    isActive?: boolean;
    schemes?: WorkflowSchemeDto[];
}

export interface WorkflowSchemeDto {
    id?: string;
    workStatus?: WorkStatusDto;
    workStatusCategory?: SimpleNavigationDto;
    order?: number;
    isActive?: boolean;
}

export interface WorkStatusDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    isActive?: boolean;
}

export interface WorkspaceListDto {
    id?: string;
    key?: string;
    name?: string;
    description?: string | undefined;
    ownership?: SimpleNavigationDto;
    isActive?: boolean;
}

export interface WorkspaceDto {
    id?: string;
    key?: string;
    name?: string;
    description?: string | undefined;
    ownership?: SimpleNavigationDto;
    workProcess?: SimpleNavigationDto;
    externalId?: string | undefined;
    externalViewWorkItemUrlTemplate?: string | undefined;
    isActive?: boolean;
}

export interface SetExternalUrlTemplatesRequest {
    externalViewWorkItemUrlTemplate?: string | undefined;
}

export interface WorkItemDetailsDto {
    id?: string;
    key?: string;
    externalId?: number | undefined;
    title?: string;
    workspace?: WorkspaceNavigationDto;
    type?: string;
    tier?: string;
    status?: string;
    statusCategory?: SimpleNavigationDto;
    priority?: number | undefined;
    parent?: WorkItemNavigationDto | undefined;
    team?: WorkTeamNavigationDto | undefined;
    assignedTo?: EmployeeNavigationDto | undefined;
    created?: Date;
    createdBy?: EmployeeNavigationDto | undefined;
    lastModified?: Date;
    lastModifiedBy?: EmployeeNavigationDto | undefined;
    activatedTimestamp?: Date | undefined;
    doneTimestamp?: Date | undefined;
    externalViewWorkItemUrl?: string | undefined;
}

export interface ScopedDependencyDto {
    id?: string;
    dependency?: WorkItemDetailsNavigationDto;
    type?: string;
    status?: SimpleNavigationDto;
    createdOn?: Date;
    createdBy?: EmployeeNavigationDto | undefined;
    comment?: string | undefined;
}

export interface WorkItemDetailsNavigationDto {
    id?: string;
    key?: string;
    title?: string;
    workspaceKey?: string;
    type?: string;
    status?: string;
    statusCategory?: SimpleNavigationDto;
    team?: WorkTeamNavigationDto | undefined;
    activatedTimestamp?: Date | undefined;
    doneTimestamp?: Date | undefined;
    externalViewWorkItemUrl?: string | undefined;
}

export interface WorkStatusCategoryListDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface CreateWorkStatusRequest {
    /** The name of the work status.  The name cannot be changed. */
    name: string;
    /** The description of the work status. */
    description?: string | undefined;
}

export interface UpdateWorkStatusRequest {
    id?: number;
    /** The description of the work status. */
    description?: string | undefined;
}

export interface WorkTypeLevelDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    tier?: SimpleNavigationDto;
    order?: number;
}

export interface CreateWorkTypeLevelRequest {
    /** The name of the work type level.  The name cannot be changed. */
    name: string;
    /** The description of the work type level. */
    description?: string | undefined;
}

export interface UpdateWorkTypeLevelRequest {
    id?: number;
    /** The name of the work type level.  The name cannot be changed. */
    name: string;
    /** The description of the work type level. */
    description?: string | undefined;
}

export interface UpdateWorkTypeLevelsOrderRequest {
    levels?: { [key: string]: number; };
}

export interface CreateWorkTypeRequest {
    /** The name of the work type.  The name cannot be changed. */
    name: string;
    /** The description of the work type. */
    description?: string | undefined;
    /** The work type level identifier. */
    levelId?: number;
}

export interface UpdateWorkTypeRequest {
    id?: number;
    /** The description of the work type. */
    description?: string | undefined;
    /** The work type level identifier. */
    levelId?: number;
}

export interface WorkTypeTierDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface EmployeeListDto {
    id?: string;
    key?: number;
    displayName?: string;
    firstName?: string;
    middleName?: string | undefined;
    lastName?: string;
    suffix?: string | undefined;
    title?: string | undefined;
    employeeNumber?: string;
    email?: string;
    jobTitle?: string | undefined;
    department?: string | undefined;
    officeLocation?: string | undefined;
    manager?: EmployeeNavigationDto | undefined;
    isActive?: boolean;
}

export interface EmployeeDetailsDto {
    id?: string;
    key?: number;
    displayName?: string;
    fullName?: string;
    firstName?: string;
    middleName?: string | undefined;
    lastName?: string;
    suffix?: string | undefined;
    title?: string | undefined;
    employeeNumber?: string;
    hireDate?: Date | undefined;
    email?: string;
    jobTitle?: string | undefined;
    department?: string | undefined;
    officeLocation?: string | undefined;
    manager?: EmployeeNavigationDto | undefined;
    isActive?: boolean;
}

export interface CreateEmployeeRequest {
    /** Gets the first name. */
    firstName: string;
    /** Gets the middle name. */
    middleName?: string | undefined;
    /** Gets the last name. */
    lastName: string;
    /** Gets the suffix. */
    suffix?: string | undefined;
    /** Gets the employee's personal title. */
    title?: string | undefined;
    /** Gets the employee number. */
    employeeNumber: string;
    /** Gets the hire date. */
    hireDate?: Date | undefined;
    /** Gets the email. */
    email: string;
    /** Gets the job title. */
    jobTitle?: string | undefined;
    /** Gets the department. */
    department?: string | undefined;
    /** Gets the office location. */
    officeLocation?: string | undefined;
    /** Gets the manager identifier. */
    managerId?: string | undefined;
}

export interface UpdateEmployeeRequest {
    /** Gets or sets the identifier. */
    id?: string;
    /** Gets the first name. */
    firstName: string;
    /** Gets the middle name. */
    middleName?: string | undefined;
    /** Gets the last name. */
    lastName: string;
    /** Gets the suffix. */
    suffix?: string | undefined;
    /** Gets the employee's personal title. */
    title?: string | undefined;
    /** Gets the employee number. */
    employeeNumber: string;
    /** Gets the hire date. */
    hireDate?: Date | undefined;
    /** Gets the email. */
    email: string;
    /** Gets the job title. */
    jobTitle?: string | undefined;
    /** Gets the department. */
    department?: string | undefined;
    /** Gets the office location. */
    officeLocation?: string | undefined;
    /** Gets the manager identifier. */
    managerId?: string | undefined;
}

export interface TeamListDto {
    id?: string;
    key?: number;
    name?: string;
    code?: string;
    type?: string;
    isActive?: boolean;
    teamOfTeams?: TeamNavigationDto | undefined;
}

export interface TeamDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    code?: string;
    description?: string | undefined;
    type?: string;
    activeDate?: Date;
    inactiveDate?: Date | undefined;
    isActive?: boolean;
    teamOfTeams?: TeamNavigationDto | undefined;
}

export interface CreateTeamRequest {
    /** Gets the team name. */
    name: string;
    /** Gets the code. */
    code: string;
    /** Gets the team description. */
    description?: string | undefined;
    /** The active date for the team. */
    activeDate: Date;
}

export interface UpdateTeamRequest {
    id?: string;
    /** Gets the team name. */
    name: string;
    /** Gets the code. */
    code: string;
    /** Gets the team description. */
    description?: string | undefined;
}

export interface DeactivateTeamRequest {
    id: string;
    inactiveDate: Date;
}

export interface TeamMembershipDto {
    id?: string;
    child?: TeamNavigationDto;
    parent?: TeamNavigationDto;
    start?: Date;
    end?: Date | undefined;
    state?: string;
}

export interface AddTeamMembershipRequest {
    teamId: string;
    parentTeamId: string;
    start: Date;
    end?: Date | undefined;
}

export interface UpdateTeamMembershipRequest {
    teamId: string;
    teamMembershipId: string;
    start: Date;
    end?: Date | undefined;
}

export interface WorkItemBacklogItemDto {
    id?: string;
    key?: string;
    title?: string;
    workspace?: WorkspaceNavigationDto;
    type?: string;
    status?: string;
    statusCategory?: SimpleNavigationDto;
    parent?: WorkItemNavigationDto | undefined;
    team?: WorkTeamNavigationDto | undefined;
    assignedTo?: EmployeeNavigationDto | undefined;
    created?: Date;
    rank?: number;
    parentRank?: number | undefined;
    externalViewWorkItemUrl?: string | undefined;
    stackRank?: number;
}

export interface DependencyDto {
    id?: string;
    source?: WorkItemDetailsNavigationDto;
    target?: WorkItemDetailsNavigationDto;
    linkType?: SimpleNavigationDto;
    status?: SimpleNavigationDto;
    createdOn?: Date;
    createdBy?: EmployeeNavigationDto | undefined;
    comment?: string | undefined;
}

export interface FunctionalOrganizationChartDto {
    asOfDate?: Date;
    organization?: OrganizationalUnitDto[];
    total?: number;
    maxDepth?: number;
}

export interface OrganizationalUnitDto {
    id?: string;
    key?: number;
    name?: string;
    code?: string;
    type?: SimpleNavigationDto;
    level?: number;
    path?: string;
    children?: OrganizationalUnitDto[] | undefined;
}

export interface TeamOfTeamsListDto {
    id?: string;
    key?: number;
    name?: string;
    code?: string;
    type?: string;
    isActive?: boolean;
    teamOfTeams?: TeamNavigationDto | undefined;
}

export interface TeamOfTeamsDetailsDto {
    id?: string;
    key?: number;
    name?: string;
    code?: string;
    description?: string | undefined;
    type?: string;
    activeDate?: Date;
    inactiveDate?: Date | undefined;
    isActive?: boolean;
    teamOfTeams?: TeamNavigationDto | undefined;
}

export interface CreateTeamOfTeamsRequest {
    /** Gets the team name. */
    name: string;
    /** Gets the code. */
    code?: string;
    /** Gets the team description. */
    description?: string | undefined;
    /** The active date for the team. */
    activeDate: Date;
}

export interface UpdateTeamOfTeamsRequest {
    id?: string;
    /** Gets the team name. */
    name: string;
    /** Gets the code. */
    code: string;
    /** Gets the team description. */
    description?: string | undefined;
}

export interface DeactivateTeamOfTeamsRequest {
    id: string;
    inactiveDate: Date;
}

export interface LinkDto {
    id?: string;
    objectId?: string;
    name?: string;
    url?: string;
}

export interface CreateLinkRequest {
    objectId: string;
    name: string;
    url: string;
}

export interface UpdateLinkRequest {
    id: string;
    name: string;
    url: string;
}

export interface HealthCheckDto {
    id?: string;
    objectId?: string;
    status?: SimpleNavigationDto;
    reportedBy?: NavigationDto;
    reportedOn?: Date;
    expiration?: Date;
    note?: string | undefined;
}

export interface CreateHealthCheckRequest {
    objectId: string;
    contextId?: number;
    statusId?: number;
    expiration: Date;
    note?: string | undefined;
}

export interface UpdateHealthCheckRequest {
    id: string;
    contextId?: number;
    statusId?: number;
    expiration: Date;
    note?: string | undefined;
}

export interface HealthStatusDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface ConnectionListDto {
    id?: string;
    name?: string;
    connector?: string;
    isActive?: boolean;
    isValidConfiguration?: boolean;
    isSyncEnabled?: boolean;
}

export interface AzureDevOpsBoardsConnectionDetailsDto {
    id?: string;
    name?: string;
    description?: string | undefined;
    connector?: string;
    configuration?: AzureDevOpsBoardsConnectionConfigurationDto;
    teamConfiguration?: AzureDevOpsBoardsTeamConfigurationDto;
    isActive?: boolean;
    isValidConfiguration?: boolean;
    isSyncEnabled?: boolean;
}

export interface AzureDevOpsBoardsConnectionConfigurationDto {
    organization?: string;
    personalAccessToken?: string;
    organizationUrl?: string;
    workProcesses?: AzureDevOpsBoardsWorkProcessDto[];
    workspaces?: AzureDevOpsBoardsWorkspaceDto[];
}

export interface AzureDevOpsBoardsWorkProcessDto {
    id?: string | undefined;
    externalId?: string;
    name?: string;
    description?: string | undefined;
    integrationState?: IntegrationStateDto | undefined;
}

export interface IntegrationStateDto {
    internalId?: string;
    isActive?: boolean;
}

export interface AzureDevOpsBoardsWorkspaceDto {
    id?: string | undefined;
    externalId?: string;
    name?: string;
    description?: string | undefined;
    workProcessId?: string;
    integrationState?: IntegrationStateDto | undefined;
}

export interface AzureDevOpsBoardsTeamConfigurationDto {
    workspaceTeams?: AzureDevOpsBoardsWorkspaceTeamDto[];
}

export interface AzureDevOpsBoardsWorkspaceTeamDto {
    workspaceId?: string;
    teamId?: string;
    teamName?: string;
    boardId?: string | undefined;
    internalTeamId?: string | undefined;
}

export interface CreateAzureDevOpsBoardConnectionRequest {
    /** Gets or sets the name of the connection. */
    name: string;
    /** Gets or sets the description. */
    description?: string | undefined;
    /** Gets the organization. */
    organization: string;
    /** Gets the personal access token. */
    personalAccessToken: string;
}

export interface UpdateAzureDevOpsBoardConnectionRequest {
    /** Gets or sets the identifier. */
    id?: string;
    /** Gets or sets the name of the connection. */
    name: string;
    /** Gets or sets the description. */
    description?: string | undefined;
    /** Gets the organization. */
    organization: string;
    /** Gets the personal access token. */
    personalAccessToken: string;
}

export interface AzdoConnectionTeamMappingsRequest {
    /** The unique identifer for the connection. */
    connectionId: string;
    /** List of team mappings. */
    teamMappings?: AzdoWorkspaceTeamMappingRequest[];
}

export interface AzdoWorkspaceTeamMappingRequest {
    /** The unique identifier for the workspace in the Azure DevOps Boards system. */
    workspaceId: string;
    /** The unique identifier for the team in the Azure DevOps Boards system. */
    teamId: string;
    /** The unique identifier for the team within Moda. */
    internalTeamId?: string | undefined;
}

export interface TestAzureDevOpsBoardConnectionRequest {
    /** Gets the organization. */
    organization?: string;
    /** Gets the personal access token. */
    personalAccessToken?: string;
}

export interface InitWorkProcessIntegrationRequest {
    /** Connection Id. */
    id: string;
    /** External identifier for the work process. */
    externalId: string;
}

export interface InitWorkspaceIntegrationRequest {
    /** Connection Id. */
    id: string;
    /** External identifier for the workspace. */
    externalId: string;
    /** The key for the workspace. */
    workspaceKey: string;
    /** The name for the workspace. */
    workspaceName: string;
    /** A url template for external work items.  This template plus the work item external id will create a url to view the work item in the external system. */
    externalViewWorkItemUrlTemplate?: string | undefined;
}

export interface ConnectorListDto {
    id?: number;
    name?: string;
    description?: string | undefined;
}

export interface BackgroundJobTypeDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    order?: number;
}

export interface BackgroundJobDto {
    id?: string;
    status?: string;
    namespace?: string;
    type?: string;
    action?: string;
    inProcessingState?: boolean;
    startedAt?: Date | undefined;
}

export interface CreateRecurringJobRequest {
    jobId?: string;
    jobTypeId?: number;
    cronExpression?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}